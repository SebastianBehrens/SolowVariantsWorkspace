sim_table[["L"]][[which(sim_table$period == i-1)]])
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[[aux_index, "alpha"]])
# View(sim_table)
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
}
remaining_vars_to_compute_bool
remaining_vars_to_compute_bool
sim_table <- add_var_computer(sim_table, remaining_vars_to_compute_bool, paragrid, "exo", "ESSEO")
sim_table
# 0.7 computing additional variables ---------------------------------
add_var_computer <- function(sim_data, add_vars, parameter_data, technology_variant, solowversion){
# sim_data for the simulation table created in every Solow Model Simulation Function (SimulateBasicSolowModel, SimulateGeneralSolowModel, SimulateExtendedSolowModelSmallOpenEconomy)
# add_vars for the vector indicating whether a variable needs to be computer or not (it will not need to be computer in the ensuing function if it is endogeneous to the model)
# parameter_data for the parameter grid
# technology variant for the version where TFP is indicated as endogeneous by A or exogeneous by B
# solowversion for a string indicating the solow model version ("BS", "GS", "ESSOE", "ES....")
# sim_data <- sim_table
# add_vars <- remaining_vars_to_compute_bool
# parameter_data <- paragrid
# technology_variant <- "exo"
# solowversion <- "ESSEO"
# accomodating for different forms of technology:
# A (endogeneous variable) and B (parameter) in the different Solow Models
if(technology_variant == "endo"){
technology <- sim_data[["TFP"]]
}else if(technology_variant == "exo"){
technology <- parameter_data[["B"]]
}else{
stop("Technology location unclear")
}
for(i in names(sim_data)[!add_vars]){
# Variants of Output
i <- "Sn"
if(i == "YpW"){sim_data[["YpW"]] <- sim_data[["Y"]]/sim_data[["L"]]}
if(i == "YpEW"){sim_data["YpEW"] <- sim_data[["Y"]]/(technology * sim_data[["L"]])}
# Variants of Output Logarithmised
if(i == "logY"){sim_data[["logY"]] <- sim_data[["Y"]] %>% log()}
if(i == "logYpW"){sim_data[["logYpW"]] <- sim_data[["YpW"]] %>% log()}
if(i == "logYpEW"){sim_data[["logYpEW"]] <- sim_data[["YpEW"]] %>% log()}
# Variants of Capital
if(i == "KpW"){sim_data[["KpW"]] <- sim_data[["K"]]/sim_data[["L"]]}
if(i == "KpEW"){sim_data["YpEW"] <- sim_data[["K"]]/(technology * sim_data[["L"]])}
# Variants of Capital Logarithmised
if(i == "logK"){sim_data[["logY"]] <- sim_data[["Y"]] %>% log()}
if(i == "logKpW"){sim_data[["logYpW"]] <- sim_data[["YpW"]] %>% log()}
if(i == "logKpEW"){sim_data[["logYpEW"]] <- sim_data[["YpEW"]] %>% log()}
# Variants of Growth
if(i == "gY"){sim_data[["gY"]] <- log(sim_data[["Y"]]) - log(lag(sim_data[["Y"]]))}
if(i == "gYpW"){sim_data[["gYpW"]] <- log(sim_data[["YpW"]]) - log(lag(sim_data[["YpW"]]))}
if(i == "gYpEW"){sim_data[["gYpEW"]] <- log(sim_data[["YpEW"]]) - log(lag(sim_data[["YpEW"]]))}
if(i == "gKpW"){sim_data[["gKpW"]] <- log(sim_data[["KpW"]]) - log(lag(sim_data[["KpW"]]))}
if(i == "gKpEW"){sim_data[["gKpEW"]] <- log(sim_data[["KpEW"]]) - log(lag(sim_data[["KpEW"]]))}
# Variants of Saving
if(i == "Sn"){sim_data[["Sn"]] <- paragrid[["s"]] * sim_data[["Yn"]]}
# Variables uniquely calculated to different Solow Model Versions (e.g. WR, RR)
# WR, RR for BS ---------------------------------
if(solowversion == "BS") {
source("BSModelFunctions.R")
if (i == "WR") {
sim_data[["WR"]] <- BS_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- BS_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
# WR, RR for GS ---------------------------------
if(solowversion == "GS") {
source("GSModelFunctions.R")
if (i == "WR") {
sim_data[["WR"]] <- GS_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- GS_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
# WR, RR for ESSOE ---------------------------------
if(solowversion == "ESSOE") {
if (i == "WR") {
source("ESSOEModelFunctions.R")
sim_data[["WR"]] <- ESSOE_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- ESSOE_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
}
return(sim_data)
}
sim_table <- add_var_computer(sim_table, remaining_vars_to_compute_bool, paragrid, "exo", "ESSEO")
sim_table
# 1.1 Simulate the Basic Solow Model =================================
SimulateExtendedSolowModelSmallOpenEconomy <- function(paragrid, np, startvals){
# Inputs ---------------------------------
# paragrid for parameter grid;
# np for number of periods;
# vts for vars to simulat
# Load Basic Model Functions ---------------------------------
source("ESSOEModelFunctions.R")
# Initialize Simulation Table ---------------------------------
sim_table <- create_simulation_table(variable_encoder(meta_ESSOE_variables), np)
# Fill Start Values for Period 0 ---------------------------------
aux_index <- which(sim_table$period == 0)
sim_table[[aux_index, "L"]] <- startvals$L
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "V"]] <- startvals$V
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[["alpha"]][[which(paragrid$period == 0)]])
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
# Computing Variables after Period 0 ---------------------------------
for (i in 1:np){
# i <- 1
aux_index <- which(sim_table$period == i)
sim_table[[aux_index, "V"]] <- ESSOE_MF_VN(sim_table[[aux_index - 1, "Yn"]],
paragrid[[aux_index - 1, "s"]],
sim_table[[aux_index - 1, "V"]])
sim_table[[aux_index, "L"]] <- ESSOE_MF_LN(paragrid[["n"]][[which(paragrid$period == i-1)]],
sim_table[["L"]][[which(sim_table$period == i-1)]])
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[[aux_index, "alpha"]])
# View(sim_table)
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
}
# Computing Additional Variables ---------------------------------
remaining_vars_to_compute_bool <- names(sim_table) %in% c("period", "L", "K", "Y", "V", "F", "Yn")
sim_table <- add_var_computer(sim_table, remaining_vars_to_compute_bool, paragrid, "exo", "ESSEO")
return(sim_table)
}
# Testing
testnamel <- c("B", "alpha", "n", "s", "r")
testivl <- c(1, 1/3,0.1, 0.2, 0.05)
testpfcl <- c(NA,NA,NA, NA, NA)
testnvl <- c(NA, NA, NA, NA, NA)
np <- 50
testgridalt <- create_parameter_grid(testnamel, testivl, testpfcl, testnvl, np)
paragrid <- testgridalt
startvals <- list(L = 1, V = 20)
testsimulation <- SimulateExtendedSolowModelSmallOpenEconomy(testgridalt, np,startvals)
testsimulation
# View(testsimulation)
VisualiseSimulation(testsimulation, variable_encoder(meta_ESSOE_variables), "free")
sim_table
View(sim_table)
testsimulation <- SimulateExtendedSolowModelSmallOpenEconomy(testgridalt, np,startvals)
# View(testsimulation)
VisualiseSimulation(testsimulation, variable_encoder(meta_ESSOE_variables), "free")
testsimulation
View(testsimulation)
testnamel <- c("B", "alpha", "n", "s", "r")
testivl <- c(1, 1/3,0.1, 0.2, 0.05)
testpfcl <- c(NA,NA,NA, NA, NA)
testnvl <- c(NA, NA, NA, NA, NA)
np <- 50
testgridalt <- create_parameter_grid(testnamel, testivl, testpfcl, testnvl, np)
paragrid <- testgridalt
startvals <- list(L = 1, V = 20)
testsimulation <- SimulateExtendedSolowModelSmallOpenEconomy(testgridalt, np,startvals)
# Initialize Simulation Table ---------------------------------
sim_table <- create_simulation_table(variable_encoder(meta_ESSOE_variables), np)
# Fill Start Values for Period 0 ---------------------------------
aux_index <- which(sim_table$period == 0)
sim_table[[aux_index, "L"]] <- startvals$L
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "V"]] <- startvals$V
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[["alpha"]][[which(paragrid$period == 0)]])
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
# Computing Variables after Period 0 ---------------------------------
for (i in 1:np){
# i <- 1
aux_index <- which(sim_table$period == i)
sim_table[[aux_index, "V"]] <- ESSOE_MF_VN(sim_table[[aux_index - 1, "Yn"]],
paragrid[[aux_index - 1, "s"]],
sim_table[[aux_index - 1, "V"]])
sim_table[[aux_index, "L"]] <- ESSOE_MF_LN(paragrid[["n"]][[which(paragrid$period == i-1)]],
sim_table[["L"]][[which(sim_table$period == i-1)]])
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[[aux_index, "alpha"]])
# View(sim_table)
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
}
remaining_vars_to_compute_bool <- names(sim_table) %in% c("period", "L", "K", "Y", "V", "F", "Yn")
sim_table <- add_var_computer(sim_table, remaining_vars_to_compute_bool, paragrid, "exo", "ESSEO")
sim_table
View(sim_table)
names(sim_table)
View(sim_table)
sim_data
sim_data[["Y"]] %>% log()
sim_table
testnamel <- c("B", "alpha", "n", "s", "r")
testivl <- c(1, 1/3,0.1, 0.2, 0.05)
testpfcl <- c(NA,NA,NA, NA, NA)
testnvl <- c(NA, NA, NA, NA, NA)
np <- 50
testgridalt <- create_parameter_grid(testnamel, testivl, testpfcl, testnvl, np)
paragrid <- testgridalt
startvals <- list(L = 1, V = 20)
# Initialize Simulation Table ---------------------------------
sim_table <- create_simulation_table(variable_encoder(meta_ESSOE_variables), np)
# Fill Start Values for Period 0 ---------------------------------
aux_index <- which(sim_table$period == 0)
sim_table[[aux_index, "L"]] <- startvals$L
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "V"]] <- startvals$V
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[["alpha"]][[which(paragrid$period == 0)]])
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
# Computing Variables after Period 0 ---------------------------------
for (i in 1:np){
# i <- 1
aux_index <- which(sim_table$period == i)
sim_table[[aux_index, "V"]] <- ESSOE_MF_VN(sim_table[[aux_index - 1, "Yn"]],
paragrid[[aux_index - 1, "s"]],
sim_table[[aux_index - 1, "V"]])
sim_table[[aux_index, "L"]] <- ESSOE_MF_LN(paragrid[["n"]][[which(paragrid$period == i-1)]],
sim_table[["L"]][[which(sim_table$period == i-1)]])
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[[aux_index, "alpha"]])
# View(sim_table)
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
}
remaining_vars_to_compute_bool <- names(sim_table) %in% c("period", "L", "K", "Y", "V", "F", "Yn")
# sim_data for the simulation table created in every Solow Model Simulation Function (SimulateBasicSolowModel, SimulateGeneralSolowModel, SimulateExtendedSolowModelSmallOpenEconomy)
# add_vars for the vector indicating whether a variable needs to be computer or not (it will not need to be computer in the ensuing function if it is endogeneous to the model)
# parameter_data for the parameter grid
# technology variant for the version where TFP is indicated as endogeneous by A or exogeneous by B
# solowversion for a string indicating the solow model version ("BS", "GS", "ESSOE", "ES....")
## Testing ESSEO
sim_data <- sim_table
add_vars <- remaining_vars_to_compute_bool
parameter_data <- paragrid
technology_variant <- "exo"
solowversion <- "ESSEO"
# accomodating for different forms of technology:
# A (endogeneous variable) and B (parameter) in the different Solow Models
if(technology_variant == "endo"){
technology <- sim_data[["TFP"]]
}else if(technology_variant == "exo"){
technology <- parameter_data[["B"]]
}else{
stop("Technology location unclear")
}
technology
# 0.7 computing additional variables ---------------------------------
add_var_computer <- function(sim_data, add_vars, parameter_data, technology_variant, solowversion){
# sim_data for the simulation table created in every Solow Model Simulation Function (SimulateBasicSolowModel, SimulateGeneralSolowModel, SimulateExtendedSolowModelSmallOpenEconomy)
# add_vars for the vector indicating whether a variable needs to be computer or not (it will not need to be computer in the ensuing function if it is endogeneous to the model)
# parameter_data for the parameter grid
# technology variant for the version where TFP is indicated as endogeneous by A or exogeneous by B
# solowversion for a string indicating the solow model version ("BS", "GS", "ESSOE", "ES....")
## Testing ESSEO
# sim_data <- sim_table
# add_vars <- remaining_vars_to_compute_bool
# parameter_data <- paragrid
# technology_variant <- "exo"
# solowversion <- "ESSEO"
# accomodating for different forms of technology:
# A (endogeneous variable) and B (parameter) in the different Solow Models
if(technology_variant == "endo"){
technology <- sim_data[["TFP"]]
}else if(technology_variant == "exo"){
technology <- parameter_data[["B"]]
}else{
stop("Technology location unclear")
}
for(i in names(sim_data)[!add_vars]){
# Variants of Output
if(i == "YpW"){sim_data[["YpW"]] <- sim_data[["Y"]]/sim_data[["L"]]}
if(i == "YpEW"){sim_data["YpEW"] <- sim_data[["Y"]]/(technology * sim_data[["L"]])}
# Variants of Output Logarithmised
if(i == "logY"){sim_data[["logY"]] <- sim_data[["Y"]] %>% log()}
if(i == "logYpW"){sim_data[["logYpW"]] <- sim_data[["YpW"]] %>% log()}
if(i == "logYpEW"){sim_data[["logYpEW"]] <- sim_data[["YpEW"]] %>% log()}
# Variants of Capital
if(i == "KpW"){sim_data[["KpW"]] <- sim_data[["K"]]/sim_data[["L"]]}
if(i == "KpEW"){sim_data["YpEW"] <- sim_data[["K"]]/(technology * sim_data[["L"]])}
# Variants of Capital Logarithmised
if(i == "logK"){sim_data[["logY"]] <- sim_data[["Y"]] %>% log()}
if(i == "logKpW"){sim_data[["logYpW"]] <- sim_data[["YpW"]] %>% log()}
if(i == "logKpEW"){sim_data[["logYpEW"]] <- sim_data[["YpEW"]] %>% log()}
# Variants of Growth
if(i == "gY"){sim_data[["gY"]] <- log(sim_data[["Y"]]) - log(lag(sim_data[["Y"]]))}
if(i == "gYpW"){sim_data[["gYpW"]] <- log(sim_data[["YpW"]]) - log(lag(sim_data[["YpW"]]))}
if(i == "gYpEW"){sim_data[["gYpEW"]] <- log(sim_data[["YpEW"]]) - log(lag(sim_data[["YpEW"]]))}
if(i == "gKpW"){sim_data[["gKpW"]] <- log(sim_data[["KpW"]]) - log(lag(sim_data[["KpW"]]))}
if(i == "gKpEW"){sim_data[["gKpEW"]] <- log(sim_data[["KpEW"]]) - log(lag(sim_data[["KpEW"]]))}
# Variants of Saving
if(i == "Sn"){sim_data[["Sn"]] <- paragrid[["s"]] * sim_data[["Yn"]]}
# Variables uniquely calculated to different Solow Model Versions (e.g. WR, RR)
# WR, RR for BS ---------------------------------
if(solowversion == "BS") {
source("BSModelFunctions.R")
if (i == "WR") {
sim_data[["WR"]] <- BS_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- BS_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
# WR, RR for GS ---------------------------------
if(solowversion == "GS") {
source("GSModelFunctions.R")
if (i == "WR") {
sim_data[["WR"]] <- GS_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- GS_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
# WR, RR for ESSOE ---------------------------------
if(solowversion == "ESSOE") {
if (i == "WR") {
source("ESSOEModelFunctions.R")
sim_data[["WR"]] <- ESSOE_MF_WR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
# Rental Rate
if (i == "RR") {
sim_data[["RR"]] <- ESSOE_MF_RR(technology,
sim_data[["K"]],
sim_data[["L"]],
parameter_data[["alpha"]])
}
}
}
return(sim_data)
}
# 1.1 Simulate the Basic Solow Model =================================
SimulateExtendedSolowModelSmallOpenEconomy <- function(paragrid, np, startvals){
# Inputs ---------------------------------
# paragrid for parameter grid;
# np for number of periods;
# vts for vars to simulat
# Load Basic Model Functions ---------------------------------
source("ESSOEModelFunctions.R")
# Initialize Simulation Table ---------------------------------
sim_table <- create_simulation_table(variable_encoder(meta_ESSOE_variables), np)
# Fill Start Values for Period 0 ---------------------------------
aux_index <- which(sim_table$period == 0)
sim_table[[aux_index, "L"]] <- startvals$L
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "V"]] <- startvals$V
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[["alpha"]][[which(paragrid$period == 0)]])
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
# Computing Variables after Period 0 ---------------------------------
for (i in 1:np){
# i <- 1
aux_index <- which(sim_table$period == i)
sim_table[[aux_index, "V"]] <- ESSOE_MF_VN(sim_table[[aux_index - 1, "Yn"]],
paragrid[[aux_index - 1, "s"]],
sim_table[[aux_index - 1, "V"]])
sim_table[[aux_index, "L"]] <- ESSOE_MF_LN(paragrid[["n"]][[which(paragrid$period == i-1)]],
sim_table[["L"]][[which(sim_table$period == i-1)]])
sim_table[[aux_index, "K"]] <- ESSOE_MF_K(paragrid[[aux_index, "r"]],
paragrid[[aux_index, "alpha"]],
paragrid[[aux_index, "B"]],
sim_table[[aux_index, "L"]])
sim_table[[aux_index, "F"]] <- ESSOE_MF_F(sim_table[[aux_index, "V"]],
sim_table[[aux_index, "K"]])
sim_table[[aux_index, "Y"]] <- ESSOE_MF_Y(paragrid[[aux_index, "B"]],
sim_table[[aux_index, "K"]],
sim_table[[aux_index, "L"]],
paragrid[[aux_index, "alpha"]])
# View(sim_table)
sim_table[[aux_index, "Yn"]] <- ESSOE_MF_Yn(sim_table[[aux_index, "Y"]],
paragrid[[aux_index, "r"]],
sim_table[[aux_index, "F"]])
}
# Computing Additional Variables ---------------------------------
remaining_vars_to_compute_bool <- names(sim_table) %in% c("period", "L", "K", "Y", "V", "F", "Yn")
sim_table <- add_var_computer(sim_table, remaining_vars_to_compute_bool, paragrid, "exo", "ESSEO")
# View(sim_table)
return(sim_table)
}
# Testing
testnamel <- c("B", "alpha", "n", "s", "r")
testivl <- c(1, 1/3,0.1, 0.2, 0.05)
testpfcl <- c(NA,NA,NA, NA, NA)
testnvl <- c(NA, NA, NA, NA, NA)
np <- 50
testgridalt <- create_parameter_grid(testnamel, testivl, testpfcl, testnvl, np)
paragrid <- testgridalt
startvals <- list(L = 1, V = 20)
testsimulation <- SimulateExtendedSolowModelSmallOpenEconomy(testgridalt, np,startvals)
# View(testsimulation)
VisualiseSimulation(testsimulation, variable_encoder(meta_ESSOE_variables), "free")
testnamel <- c("B", "alpha", "n", "s", "r")
testivl <- c(1, 1/3,0.1, 0.2, 0.05)
testpfcl <- c(NA,NA,NA, NA, NA)
testnvl <- c(NA, NA, NA, NA, NA)
np <- 50
testgridalt <- create_parameter_grid(testnamel, testivl, testpfcl, testnvl, np)
paragrid <- testgridalt
startvals <- list(L = 1, V = 30)
testsimulation <- SimulateExtendedSolowModelSmallOpenEconomy(testgridalt, np,startvals)
# View(testsimulation)
VisualiseSimulation(testsimulation, variable_encoder(meta_ESSOE_variables), "free")
